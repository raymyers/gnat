////////////////////////////////////////////////////////////////////////////////
/// @file         CUDTracer.cpp
///
/// @author       Ray Myers
///
/// @compiler     Windows: MinGW / Linux: GNU G++
///
/// @project      GNAT
///
/// @description  This file contains the implementation of the CUDTracer
///               and SUDLine classes. The "UD" stands for "Uni-Directional".
///	              CUDTracer is the class that executes all Uni-Directional
///               single agent traces.
///
////////////////////////////////////////////////////////////////////////////////

#include "CUDTracer.h"
#include "IOpenList.h"
#include <QMessageBox>

////////////////////////////////////////////////////////////////////////////////
/// CUDTracer<OpenListType>::trace
///
/// @description    Executes a trace on the root node.
/// @pre            graph points to a graph model object.
/// @post           returns trace.
///
/// @param graph: Model interface of graph to be traced.
///        depthLimit: Depth Limit.
///        iterativeDeepening: Toggles iterative deepening.
///        graphSearch: true for graph search, false for tree search.
///
/// @return STreeTrace *: This is the trace generated by the ITreeTracer
///                       subclass.
/// @limitations    None.
///
////////////////////////////////////////////////////////////////////////////////
template <class OpenListType>
SPuzzleTrace *CUDTracer<OpenListType>::trace( const int depthLimit,
                                const bool iterativeDeepening,
                                const bool graphSearch,
                                const CPuzzleGraphModel *graph ) const
{
    bool goalFound = false;
    int openNo = 0;
    int evalNo = 1;
    int depth;

    if( graphSearch ) evalNo++;
    SPuzzleTrace *newTrace = new SPuzzleTrace;

    if( graph->getStartNode() == NULL ) return newTrace;

    newTrace->s_aiName = "name";
    newTrace->s_columnNames.append("open");
    if( graphSearch ) newTrace->s_columnNames.append("closed");
    newTrace->s_columnNames.append("eval");
    newTrace->s_columnNames.append("");

    if(iterativeDeepening)
        depth = 0;
    else
        depth = depthLimit;

    while(depth <= depthLimit && !goalFound) {
    
        SPuzzleCall *curDepth = new SPuzzleCall;
        if(iterativeDeepening)
            curDepth->s_prelude = QString("depth-limit=%1").arg(depth);
        bool isDepthLimitReached = false;
        OpenListType open;
        CClosedList closed;

        open.push( CSATraceNode(graph->getStartNode()) );

        for(;;) {

            CSATraceNode evalNode = open.top();
            SUDLine *curLine = new SUDLine;

            curLine->s_strings.append( open.getString() );

            if( graphSearch ) curLine->s_strings.append( closed.getString() );

            curLine->s_strings.append( open.getEvalString() );

            curDepth->s_lines.append( curLine );

            if( evalNode.goalTest() ) {
                // GOAL FOUND!
                goalFound = true;
                // Add relevant comment and break out of loop
                //curLine->s_strings.append(
                //    goalString(graph, curDepth->s_lines, evalNode, openNo, evalNo) );

                curDepth->s_comment =
                    goalString(graph, curDepth->s_lines, evalNode, openNo, evalNo);
                break;
            }

            if( !graphSearch && curDepth->s_lines.count() > 30) {
                //curLine->s_strings.append("Ad Infinitum");
                curDepth->s_comment = "Ad Infinitum";
                break;
            }
            //curLine->s_strings.append(""); // add blank comment;

            // Remove eval node from front of open list.
            open.pop();

            // Push all of eval node's children onto open list,
            // with given depth limit. Strip away any nodes that
            // are on the closed list.
            open.push(
                closed.strip(
                    evalNode.expand(depth, isDepthLimitReached) ) );

            if(graphSearch) open.removeDuplicates();

            if( open.empty() ) {
                //curLine->s_strings.append("search completed and no goal found");
                if(isDepthLimitReached)
                    curDepth->s_comment = "depth-limit reached and no goal found";
                else
                    curDepth->s_comment = "search completed and no goal found";
                break;
            }

            if( graphSearch ) closed.push(evalNode);

        }
        newTrace->s_depths.append( curDepth );
        depth++;
    }

    return newTrace;
}

// To define a templated member function outside the class declaration,
// every form that will be used must be separately prototyped.

template SPuzzleTrace *CUDTracer<CDFOpenList>::trace( const int depthLimit,
                                const bool iterativeDeepening,
                                const bool graphSearch,
                                const CPuzzleGraphModel *graph ) const;

template SPuzzleTrace *CUDTracer<CBFOpenList>::trace( const int depthLimit,
                                const bool iterativeDeepening,
                                const bool graphSearch,
                                const CPuzzleGraphModel *graph ) const;

template SPuzzleTrace *CUDTracer<CUCOpenList>::trace( const int depthLimit,
                                const bool iterativeDeepening,
                                const bool graphSearch,
                                const CPuzzleGraphModel *graph ) const;

template SPuzzleTrace *CUDTracer<CGBFOpenList>::trace( const int depthLimit,
                                const bool iterativeDeepening,
                                const bool graphSearch,
                                const CPuzzleGraphModel *graph ) const;

template SPuzzleTrace *CUDTracer<CAStarOpenList>::trace( const int depthLimit,
                                const bool iterativeDeepening,
                                const bool graphSearch,
                                const CPuzzleGraphModel *graph ) const;

////////////////////////////////////////////////////////////////////////////////
/// CUDTracer<OpenListType>::goalString
///
/// @description Get the goal string, including path and path cost.
/// @pre         goal is the goal node. lines contains the resuts of
///              successfull trace call.
/// @post        Appropriate goal comment string is returned.
///
/// @param graph: pointer to graph model (currently unused.
///        lines: Trace output to be analized.
///        goal:  Goal node.
///        iOpen: index of the open list in trace lines.
///        iEval: index of the eval node in trace lines.
///
/// @limitations    None.
///
////////////////////////////////////////////////////////////////////////////////
template <class OpenListType>
QString CUDTracer<OpenListType>::goalString(const CPuzzleGraphModel *graph,
                   const QList<IPuzzleLine *> lines, CSATraceNode goal, int iOpen, int iEval) const
{
    QString solution;
    QStringList nodes;

    // set curNode equal to goal node.
    QString curNode = lines.back()->toStringList()[iEval];
    QString startNode = lines.front()->toStringList()[iEval];
    //return startNode + curNode;
    int curLineNo = lines.count()-1;
    int i;
    for(;;)
    {
        solution.push_front(curNode);
        // If we've traced all the way back to the beginning, we're done.
        if(startNode == curNode)
            break;
        // Search for first open list that contains curNode.
        for(i=curLineNo; i>=0; --i)
            // If open list for current line contains curnode, break out
            // of loop.
            if( !lines[i]->toStringList()[iOpen].split(" ").contains(curNode) )
		break;
        // Next element in solution is the Eval node of the line above.
        curLineNo = i-1;
        curNode = lines[i]->toStringList()[iEval];
    }

    // This is a hack to remove cost and heuristic info from the solution.
    // It will remove part of the name of a node if the name contains numbers.
    solution.remove(QRegExp("\\d"));
    solution.remove(".");
    solution.remove("-");

    return QString("goal found; solution = ") +
           solution +
           QString("; path-cost(") +
           solution +
           QString(") = ") +
           QString::number( goal.getCost() );
}

////////////////////////////////////////////////////////////////////////////////
/// SUDLine::SUDLine
///
/// @description Constructor
/// @pre         None.
/// @post        Object is created.
///
/// @param
///
/// @limitations    None.
///
////////////////////////////////////////////////////////////////////////////////
SUDLine::SUDLine() {}

////////////////////////////////////////////////////////////////////////////////
/// SUDLine::~SUDLine
///
/// @description Destructor
/// @pre         None.
/// @post        Object is destroyed.
///
/// @param
///
/// @limitations    None.
///
////////////////////////////////////////////////////////////////////////////////
SUDLine::~SUDLine() {}

////////////////////////////////////////////////////////////////////////////////
/// SUDLine::operator []
///
/// @description Subscript operator.
/// @pre         s_strings[index] exists.
/// @post        s_strings[index] is returned.
///
/// @param index:   Index of string to be returned.
///
/// @limitations    No bounds checking.
///
////////////////////////////////////////////////////////////////////////////////
QString SUDLine::operator [](int index)
{
    return s_strings[index];
}

////////////////////////////////////////////////////////////////////////////////
/// SUDLine::toStringList
///
/// @description Accessor function for s_strings.
/// @pre         None.
/// @post        Copy of s_strings, with a blank string appended is returned.
///
/// @param
///
/// @limitations    None.
///
////////////////////////////////////////////////////////////////////////////////
QStringList SUDLine::toStringList()
{
    QStringList ret = s_strings;
    ret.append("");
    return ret;
}
