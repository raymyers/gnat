////////////////////////////////////////////////////////////////////////////////
/// @file         CBDTracer.cpp
///
/// @author       Ray Myers
///
/// @compiler     Windows: MinGW / Linux: GNU G++
///
/// @project      GNAT
///
/// @description  This file contains the declaration of the CBDTracer
///               and SBDLine classes. The "BD" stands for "Bi-Directional".
///               CBDTracer is the class that executes all Bi-Directional
///               single agent traces.
///
////////////////////////////////////////////////////////////////////////////////

#include "CBDTracer.h"
#include "IOpenList.h"
#include<QMessageBox>

////////////////////////////////////////////////////////////////////////////////
/// CBDTracer::trace
///
/// @description     Executes a trace from the start node and the first goal node.
/// @pre             graph points to a graph model object.
/// @post            returns trace.
///
/// @param graph: Model interface of graph to be traced.
///        depthLimit: Depth Limit.
///        iterativeDeepening: Toggles iterative deepening.
///        graphSearch: true for graph search, false for tree search.
///
/// @return STreeTrace *: This is the trace generated by the ITreeTracer
///                       subclass.
/// @limitations    Cannot choose which goal to search backward from.
///
////////////////////////////////////////////////////////////////////////////////

template <class OpenListType>
SPuzzleTrace *CBDTracer<OpenListType>::trace( const int depthLimit,
                                const bool iterativeDeepening,
                                const bool graphSearch,
                                const CPuzzleGraphModel *graph ) const
{
    bool goalFound = false;
    int openNoForward  = 0;
    int evalNoForward  = 1 + 1*graphSearch;
    int openNoBackward = 2 + 1*graphSearch;
    int evalNoBackward = 3 + 2*graphSearch;
    int depth;

    //if( graphSearch ) evalNo++;
    SPuzzleTrace *newTrace = new SPuzzleTrace;

    if( graph->getStartNode() == NULL ) return newTrace;

    newTrace->s_aiName = "name";
    newTrace->s_columnNames.append("open");
    if( graphSearch ) newTrace->s_columnNames.append("closed");
    newTrace->s_columnNames.append("eval");

    newTrace->s_columnNames.append("open");
    if( graphSearch ) newTrace->s_columnNames.append("closed");
    newTrace->s_columnNames.append("eval");

    newTrace->s_columnNames.append("");

    if(iterativeDeepening)
        depth = 0;
    else
        depth = depthLimit;

    while(depth <= depthLimit && !goalFound)
    {
        SPuzzleCall *curDepth = new SPuzzleCall;
        OpenListType openForward, openBackward;
        CClosedList closedForward, closedBackward;
        CSATraceNode evalNodeForward, evalNodeBackward;
        bool exaustedForward = false;
        bool exaustedBackward = false;




        QList<SPuzzleNode *> goals = graph->getGoalNodeList();

        QList< CSATraceNode > historyForward;
        QList< CSATraceNode > historyBackward;

        if(goals.empty())
        {
            curDepth->s_comment = "Cannot commence bi-directional search - no goals";
            newTrace->s_depths.append( curDepth );
            return newTrace;
        }
        openForward.push( CSATraceNode( graph->getStartNode() ) );
        openBackward.push( CSATraceNode( goals.first() ) );
        for(;;)
        {
            SBDLine *curLine = new SBDLine;

            if(exaustedForward)
            {
                curLine->s_strings.append( QString() ); // open
                curLine->s_strings.append( QString() ); // eval
                if( graphSearch )
                    curLine->s_strings.append( QString() ); // closed
                goto backward;
            }

            ////////////////////////////////////////////
            // Forward Search
            ////////////////////////////////////////////

            evalNodeForward = openForward.top();

            curLine->s_strings.append( openForward.getString() );

            if( graphSearch ) curLine->s_strings.append( closedForward.getString() );

            curLine->s_strings.append( openForward.getEvalString() );
            historyForward.append( evalNodeForward );


            if( historyBackward.contains( evalNodeForward ) )
            {
                // GOAL FOUND!
                goalFound = true;
                // Add relevant comment and break out of loop
                //curLine->s_strings.append(
                 //goalString(graph, curDepth->s_lines, evalNode, openNo, evalNo) );
                int index = historyBackward.indexOf( evalNodeForward );

                int cost = evalNodeForward.getCost() +  historyBackward[index].getCost();

                // Midpoint may have different
                curDepth->s_lines.append( curLine );

                curDepth->s_comment =
                    goalString(graph, curDepth->s_lines, curDepth->s_lines.size()-1, index , cost,
                               openNoForward, evalNoForward, openNoBackward, evalNoBackward);

                    /*int numStrings = curLine->s_strings.size();
                    for(int i=0; i<numStrings; i++)
                        curLine->s_strings.append( QString() );
                */


                break;
            }


            //curLine->s_strings.append(""); // add blank comment;

            // Remove eval node from front of open list.
            openForward.pop();

            // Push all of eval node's children onto open list,
            // with given depth limit. Strip away any nodes that
            // are on the closed list.
            openForward.push(
                closedForward.strip(
                    evalNodeForward.expand(depth) ) );

            if( openForward.empty() )
            {
                if( exaustedBackward )
                {
                    curDepth->s_lines.append( curLine );
                    curDepth->s_comment = "search completed and no goal found";
                    break;
                }
                else
                {
                    exaustedForward = true;
                }
            }

            if( graphSearch ) closedForward.push(evalNodeForward);




backward:
            if(exaustedBackward)
            {
                curDepth->s_lines.append( curLine );
                continue;
            }
            ////////////////////////////////////////////
            // Backward Search
            ////////////////////////////////////////////

            evalNodeBackward = openBackward.top();

            curLine->s_strings.append( openBackward.getString() );

            if( graphSearch ) curLine->s_strings.append( closedBackward.getString() );

            curLine->s_strings.append( openBackward.getEvalString() );

            historyBackward.append( evalNodeBackward );

            curDepth->s_lines.append( curLine );

            if( historyForward.contains( evalNodeBackward ) )
            {
                // GOAL FOUND!
                goalFound = true;
                // Add relevant comment and break out of loop
                int index = historyForward.indexOf( evalNodeBackward );

                int cost = evalNodeBackward.getCost() +  historyForward[index].getCost();

                curDepth->s_comment =
                    goalString(graph, curDepth->s_lines, index, curDepth->s_lines.size()-1, cost,
                               openNoForward, evalNoForward, openNoBackward, evalNoBackward);
                break;
            }

            if( !graphSearch && curDepth->s_lines.count() > 30)
            {
                curDepth->s_comment = "Ad Infinitum";
                break;
            }
            //curLine->s_strings.append(""); // add blank comment;

            // Remove eval node from front of open list.
            openBackward.pop();

            // Push all of eval node's children onto open list,
            // with given depth limit. Strip away any nodes that
            // are on the closed list.
            openBackward.push(
                closedBackward.strip(
                    evalNodeBackward.expandBackward(depth) ) );

            if( openBackward.empty() )
            {
                if( exaustedForward )
                {
                    curDepth->s_comment = "search completed and no goal found";
                    break;
                }
                else
                {
                    exaustedBackward = true;
                }
            }

            if( graphSearch ) closedBackward.push(evalNodeBackward);

        }
        newTrace->s_depths.append( curDepth );
        depth++;
    }



    return newTrace;
}

// To define a templated member function outside the class declaration,
// every form that will be used must be separately prototyped.

template SPuzzleTrace *CBDTracer<CDFOpenList>::trace( const int depthLimit,
                                const bool iterativeDeepening,
                                const bool graphSearch,
                                const CPuzzleGraphModel *graph ) const;

template SPuzzleTrace *CBDTracer<CBFOpenList>::trace( const int depthLimit,
                                const bool iterativeDeepening,
                                const bool graphSearch,
                                const CPuzzleGraphModel *graph ) const;

template SPuzzleTrace *CBDTracer<CUCOpenList>::trace( const int depthLimit,
                                const bool iterativeDeepening,
                                const bool graphSearch,
                                const CPuzzleGraphModel *graph ) const;

// Bi-Directional versions of GBF and A* are presumed to be functional,
// but heuristic values make no sense in reverse.
/*
template SPuzzleTrace *CBDTracer<CGBFOpenList>::trace( const int depthLimit,
                                const bool iterativeDeepening,
                                const bool graphSearch,
                                const CPuzzleGraphModel *graph ) const;

template SPuzzleTrace *CBDTracer<CAStarOpenList>::trace( const int depthLimit,
                                const bool iterativeDeepening,
                                const bool graphSearch,
                                const CPuzzleGraphModel *graph ) const;
*/

// This function turned out to be unneeded.
/*
template <class OpenListType>
bool CBDTracer<OpenListType>::nodeNameMatch(QString n1, QString n2) const
{
    n1.remove(QRegExp("\\d"));
    n1.remove(".");
    n1.remove("-");

    n2.remove(QRegExp("\\d"));
    n2.remove(".");
    n2.remove("-");

    return n1 == n2;
}
*/

////////////////////////////////////////////////////////////////////////////////
/// CBDTracer::goalString
///
/// @description Get the goal string, including path and path cost.
/// @pre         goal is the goal node. lines contains the resuts of
///              successfull trace call.
/// @post        Appropriate goal comment string is returned.
///
/// @param graph: pointer to graph model (currently unused.
///        lines: Trace output to be analized.
///        indexF: line the midpoint appeared in the forward trace.
///        indexB: line the midpoint appeared in the backward trace.
///        iOpenForward: index of the forward open list in trace lines.
///        iEvalForward: index of the forward eval node in trace lines.
///        iOpenBackward: index of the backward open list in trace lines.
///        iEvalBackward: index of the backward eval node in trace lines.
///
/// @limitations    None.
///
////////////////////////////////////////////////////////////////////////////////
template <class OpenListType>
QString CBDTracer<OpenListType>::goalString(const CPuzzleGraphModel *graph,
                   const QList<IPuzzleLine *> lines, int indexF, int indexB, int cost,
                   int iOpenForward,  int iEvalForward,
                   int iOpenBackward, int iEvalBackward) const
{
    QString solution;
    QStringList nodes;

    // set curNode equal to goal node.
    QString curNode;
    QString startNode = lines.front()->toStringList()[iEvalForward];
    QString endNode   = lines.front()->toStringList()[iEvalBackward];
    //return startNode + curNode;
    int curLineNo = indexF;
    int i;

    curNode = lines[curLineNo]->toStringList()[iEvalForward];
    for(;;)
    {
        solution.push_front(curNode);
        // If we've traced all the way back to the beginning, we're done.
        if(startNode == curNode)
            break;
        // Search for first open list that contains curNode.
        for(i=1; i<curLineNo; ++i)
            // If open list for current line contains curnode, break out
            // of loop.
            if( lines[i]->toStringList()[iOpenForward].split(" ").contains(curNode) )
            //if( lines[i]->toStringList()[iOpen].contains(curNode) )
                break;
        // Next element in solution is the Eval node of the line above.
        curLineNo = i-1;
        curNode = lines[i-1]->toStringList()[iEvalForward];
    }

    //solution.pop_back();

    curLineNo = indexB;
    curNode = lines[curLineNo]->toStringList()[iEvalBackward];

    for(;;)
    {

        // If we've traced all the way back to the beginning, we're done.
        if(endNode == curNode)
            break;
        // Search for first open list that contains curNode.
        for(i=1; i<curLineNo; ++i)
            // If open list for current line contains curnode, break out
            // of loop.
            if( lines[i]->toStringList()[iOpenBackward].split(" ").contains(curNode) )
            //if( lines[i]->toStringList()[iOpen].contains(curNode) )
                break;
        // Next element in solution is the Eval node of the line above.
        curLineNo = i-1;
        curNode = lines[i-1]->toStringList()[iEvalBackward];

        solution.push_back(curNode);
    }

    // This is a hack to remove cost and heuristic info from the solution.
    // It will remove part of the name of a node if the name contains numbers.
    solution.remove(QRegExp("\\d"));
    solution.remove(".");
    solution.remove("-");

    return QString("goal found; solution = ") +
           solution +
           QString("; path-cost(") +
           solution +
           QString(") = ") +
           QString::number( cost);
}

////////////////////////////////////////////////////////////////////////////////
/// SBFGSLine::SBFGSLine
///
/// @description Constructor
/// @pre         None.
/// @post        Object is created.
///
/// @param
///
/// @limitations    None.
///
////////////////////////////////////////////////////////////////////////////////
SBDLine::SBDLine() {}

////////////////////////////////////////////////////////////////////////////////
/// SBFGSLine::~SBFGSLine
///
/// @description Destructor
/// @pre         None.
/// @post        Object is destroyed.
///
/// @param
///
/// @limitations    None.
///
////////////////////////////////////////////////////////////////////////////////
SBDLine::~SBDLine() {}

////////////////////////////////////////////////////////////////////////////////
/// SBDLine::operator []
///
/// @description Subscript operator.
/// @pre         none.
/// @post        s_strings[index] is returned, or a blank string if out of bounds.
///
/// @param index:   Index of string to be returned.
///
/// @limitations    None.
///
//////////////////////////////////////////////////////////////////////////
QString SBDLine::operator [](int index)
{
    if( index < s_strings.size() )
        return s_strings[index];
    else
        return QString();
}

////////////////////////////////////////////////////////////////////////////////
/// SBDLine::toStringList
///
/// @description Accessor function for s_strings.
/// @pre         None.
/// @post        Copy of s_strings, padded to make size atleast 7 (just to be safe).
///
/// @param
///
/// @limitations    None.
///
////////////////////////////////////////////////////////////////////////////////
QStringList SBDLine::toStringList()
{
    QStringList ret = s_strings;
    while( ret.size() < 7)
        ret.append("");
    return ret;
}
